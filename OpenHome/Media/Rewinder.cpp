#include <OpenHome/Media/Rewinder.h>
#include <OpenHome/Media/Pipeline.h>

using namespace OpenHome;
using namespace OpenHome::Media;

Rewinder::Rewinder(MsgFactory& aMsgFactory, IPipelineElementUpstream& aUpstreamElement, TUint aSlots)
    : iMsgFactory(aMsgFactory)
    , iUpstreamElement(aUpstreamElement)
    , iStreamHandler(NULL)
    , iBuffering(false)
{
    iFifoCurrent = new Fifo<MsgAudioEncoded*>(aSlots);
    iFifoNext = new Fifo<MsgAudioEncoded*>(aSlots);
}

Rewinder::~Rewinder()
{
    DrainFifo(*iFifoCurrent);
    DrainFifo(*iFifoNext);
    delete iFifoCurrent;
    delete iFifoNext;
}

MsgAudioEncoded* Rewinder::GetAudioFromCurrent()
{
    ASSERT(iFifoCurrent->SlotsUsed() > 0);
    MsgAudioEncoded* msg = NULL;
    if (iBuffering) {
        ASSERT(iFifoNext->SlotsFree() > 0);
        msg = iFifoCurrent->Read();
        msg->AddRef();
        iFifoNext->Write(msg);
    }
    else {
        msg = iFifoCurrent->Read();
    }
    return msg;
}

void Rewinder::DrainFifo(Fifo<MsgAudioEncoded*>& aFifo)
{
    MsgAudioEncoded* msg;
    while (aFifo.SlotsUsed() > 0) {
        msg = aFifo.Read();
        msg->RemoveRef();
    }
}

Msg* Rewinder::Pull()
{
    Msg* msg = NULL;
    // check if we have a waiting MsgAudioEncoded as first part of short-circuit
    while (iFifoCurrent->SlotsUsed() == 0 && msg == NULL) {
        msg = iUpstreamElement.Pull();
        if (msg != NULL) {
            msg = msg->Process(*this);
        }
    }
    if (iFifoCurrent->SlotsUsed() > 0) {
        ASSERT(msg == NULL);
        msg = GetAudioFromCurrent();
    }
    return msg;
}

Msg* Rewinder::ProcessMsg(MsgAudioEncoded* aMsg)
{
    ASSERT(iFifoCurrent->SlotsFree() > 0);
    ASSERT(iFifoNext->SlotsFree() > 0);
    iFifoCurrent->Write(aMsg);
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgAudioPcm* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgSilence* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgPlayable* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgDecodedStream* /*aMsg*/)
{
    ASSERTS(); // expect this Msg to be generated by a downstream decoder element
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgTrack* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgEncodedStream* aMsg)
{
    iBuffering = true;
    // clear data in case previous stream was exhausted while buffering
    DrainFifo(*iFifoCurrent);
    DrainFifo(*iFifoNext);
    iStreamHandler = aMsg->StreamHandler();
    MsgEncodedStream* msg = iMsgFactory.CreateMsgEncodedStream(aMsg->Uri(), aMsg->MetaText(), aMsg->TotalBytes(), aMsg->StreamId(), aMsg->Seekable(), aMsg->Live(), this);
    aMsg->RemoveRef();
    return msg;
}

Msg* Rewinder::ProcessMsg(MsgMetaText* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgHalt* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgFlush* aMsg)
{
    iBuffering = false;
    DrainFifo(*iFifoCurrent);
    DrainFifo(*iFifoNext);
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgQuit* aMsg)
{
    return aMsg;
}

EStreamPlay Rewinder::OkToPlay(TUint aTrackId, TUint aStreamId)
{
    return iStreamHandler->OkToPlay(aTrackId, aStreamId);
}

TUint Rewinder::TrySeek(TUint aTrackId, TUint aStreamId, TUint64 aOffset)
{
    if (iBuffering) {
        ASSERT(aOffset == 0); // shouldn't be seeking back to anywhere other than start while buffering/recognising
        // write any msgs from iFifoCurrent into iFifoNext, then set iFifoNext as iFifoCurrent
        while (iFifoCurrent->SlotsUsed() > 0) {
            iFifoNext->Write(iFifoCurrent->Read());
        }
        Fifo<MsgAudioEncoded*>* tmp = iFifoCurrent;
        iFifoCurrent = iFifoNext;
        iFifoNext = tmp;
        return MsgFlush::kIdInvalid;
    }
    else {
        // no need to store reference to flush id as we don't buffer msgs during normal operation
        return iStreamHandler->TrySeek(aTrackId, aStreamId, aOffset);
    }
}

TUint Rewinder::TryStop(TUint aTrackId, TUint aStreamId)
{
    if (iBuffering) {
        iBuffering = false;
        DrainFifo(*iFifoNext);
        return MsgFlush::kIdInvalid;
    }
    else {
        return iStreamHandler->TryStop(aTrackId, aStreamId);
    }
}
