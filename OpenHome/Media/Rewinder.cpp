#include <OpenHome/Media/Rewinder.h>
#include <OpenHome/Media/Pipeline.h>

using namespace OpenHome;
using namespace OpenHome::Media;

Rewinder::Rewinder(MsgFactory& aMsgFactory, IPipelineElementUpstream& aUpstreamElement, IFlushIdProvider& aIdProvider)
    : iMsgFactory(aMsgFactory)
    , iUpstreamElement(aUpstreamElement)
    , iIdProvider(aIdProvider)
    , iStreamHandler(NULL)
    , iBuffering(false)
{
    iQueueCurrent = new MsgQueue();
    iQueueNext = new MsgQueue();
}

Rewinder::~Rewinder()
{
    delete iQueueCurrent;
    delete iQueueNext;
}

Msg* Rewinder::GetAudioFromCurrent()
{
    ASSERT(!iQueueCurrent->IsEmpty());
    Msg* msg = NULL;
    if (iBuffering) {
        msg = iQueueCurrent->Dequeue();
        msg->AddRef();
        iQueueNext->Enqueue(msg);
    }
    else {
        msg = iQueueCurrent->Dequeue();
    }
    return msg;
}

void Rewinder::DrainQueue(MsgQueue& aQueue)
{
    Msg* msg;
    while (!aQueue.IsEmpty()) {
        msg = aQueue.Dequeue();
        msg->RemoveRef();
    }
}

Msg* Rewinder::Pull()
{
    Msg* msg = NULL;

    if (!iFlushQueue.IsEmpty()) {
        return iFlushQueue.Dequeue();
    }

    // check if we have a waiting MsgAudioEncoded as first part of short-circuit
    while (iQueueCurrent->IsEmpty() && msg == NULL) {
        msg = iUpstreamElement.Pull();
        if (msg != NULL) {
            msg = msg->Process(*this);
        }
    }
    if (!iQueueCurrent->IsEmpty()) {
        ASSERT(msg == NULL);
        msg = GetAudioFromCurrent();
    }
    return msg;
}

Msg* Rewinder::ProcessMsg(MsgAudioEncoded* aMsg)
{
    iQueueCurrent->Enqueue(aMsg);
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgAudioPcm* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgSilence* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgPlayable* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgDecodedStream* /*aMsg*/)
{
    ASSERTS(); // expect this Msg to be generated by a downstream decoder element
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgTrack* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgEncodedStream* aMsg)
{
    iBuffering = true;
    // clear data in case previous stream was exhausted while buffering
    DrainQueue(*iQueueCurrent);
    DrainQueue(*iQueueNext);
    iStreamHandler = aMsg->StreamHandler();
    MsgEncodedStream* msg = iMsgFactory.CreateMsgEncodedStream(aMsg->Uri(), aMsg->MetaText(), aMsg->TotalBytes(), aMsg->StreamId(), aMsg->Seekable(), aMsg->Live(), this);
    aMsg->RemoveRef();
    return msg;
}

Msg* Rewinder::ProcessMsg(MsgMetaText* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgHalt* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgFlush* aMsg)
{
    iBuffering = false;
    DrainQueue(*iQueueCurrent);
    DrainQueue(*iQueueNext);
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgQuit* aMsg)
{
    return aMsg;
}

EStreamPlay Rewinder::OkToPlay(TUint aTrackId, TUint aStreamId)
{
    return iStreamHandler->OkToPlay(aTrackId, aStreamId);
}

TUint Rewinder::TrySeek(TUint aTrackId, TUint aStreamId, TUint64 aOffset)
{
    if (iBuffering) {
        ASSERT(aOffset == 0); // shouldn't be seeking back to anywhere other than start while buffering/recognising
        // write any msgs from iQueueCurrent into iQueueNext, then set iQueueNext as iQueueCurrent
        while (!iQueueCurrent->IsEmpty()) {
            iQueueNext->Enqueue(iQueueCurrent->Dequeue());
        }
        MsgQueue* tmpQueue = iQueueCurrent;
        iQueueCurrent = iQueueNext;
        iQueueNext = tmpQueue;
        TUint flushId = iIdProvider.NextFlushId();
        iFlushQueue.Enqueue(iMsgFactory.CreateMsgFlush(flushId));
        return flushId;
    }
    else {
        return iStreamHandler->TrySeek(aTrackId, aStreamId, aOffset);
    }
}

TUint Rewinder::TryStop(TUint aTrackId, TUint aStreamId)
{
    if (iBuffering) {
        iBuffering = false;
        DrainQueue(*iQueueNext);
        return MsgFlush::kIdInvalid;
    }
    else {
        return iStreamHandler->TryStop(aTrackId, aStreamId);
    }
}
