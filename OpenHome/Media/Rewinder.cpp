#include <OpenHome/Media/Rewinder.h>
#include <OpenHome/Media/Pipeline.h>
#include <OpenHome/Private/Thread.h>

using namespace OpenHome;
using namespace OpenHome::Media;

Rewinder::Rewinder(MsgFactory& aMsgFactory, IPipelineElementUpstream& aUpstreamElement)
    : iMsgFactory(aMsgFactory)
    , iUpstreamElement(aUpstreamElement)
    , iStreamHandler(NULL)
    , iBuffering(false)
    , iLock("REWI")
    , iTrackId(0)
    , iStreamId(0)
{
    iQueueCurrent = new MsgQueue();
    iQueueNext = new MsgQueue();
}

Rewinder::~Rewinder()
{
    delete iQueueCurrent;
    delete iQueueNext;
}

Msg* Rewinder::GetAudioFromCurrent()
{
    ASSERT(!iQueueCurrent->IsEmpty());
    MsgAudioEncoded* msg = NULL;
    msg = dynamic_cast<MsgAudioEncoded*>(iQueueCurrent->Dequeue());
    if (iBuffering) {
        try {
            MsgAudioEncoded* clone = msg->Clone();
            iQueueNext->Enqueue(clone);
        }
        catch (AllocatorNoMemory&) {
            // can't clone msg; push back onto head of current queue so memory isn't lost
            iQueueCurrent->EnqueueAtHead(msg);
            throw; // can't do anything other than pass exception on now
        }
    }
    return msg;
}

void Rewinder::DrainQueue(MsgQueue& aQueue)
{
    Msg* msg;
    while (!aQueue.IsEmpty()) {
        msg = aQueue.Dequeue();
        msg->RemoveRef();
    }
}

Msg* Rewinder::Pull()
{
    Msg* msg = NULL;
    AutoMutex a(iLock);

    if (!iFlushQueue.IsEmpty()) {
        return iFlushQueue.Dequeue();
    }

    // check if we have a waiting MsgAudioEncoded as first part of short-circuit
    while (iQueueCurrent->IsEmpty() && msg == NULL) {
        msg = iUpstreamElement.Pull();
        if (msg != NULL) {
            msg = msg->Process(*this);
        }
    }
    if (!iQueueCurrent->IsEmpty()) {
        ASSERT(msg == NULL);
        msg = GetAudioFromCurrent();
    }
    return msg;
}

Msg* Rewinder::ProcessMsg(MsgAudioEncoded* aMsg)
{
    iQueueCurrent->Enqueue(aMsg);
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgAudioPcm* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgSilence* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgPlayable* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgDecodedStream* /*aMsg*/)
{
    ASSERTS(); // expect this Msg to be generated by a downstream decoder element
    return NULL;
}

Msg* Rewinder::ProcessMsg(MsgTrack* aMsg)
{
    iTrackId = aMsg->IdPipeline();
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgEncodedStream* aMsg)
{
    iBuffering = true;
    // clear data in case previous stream was exhausted while buffering
    DrainQueue(*iQueueCurrent);
    DrainQueue(*iQueueNext);
    iStreamHandler = aMsg->StreamHandler();
    iStreamId = aMsg->StreamId();
    MsgEncodedStream* msg = iMsgFactory.CreateMsgEncodedStream(aMsg->Uri(), aMsg->MetaText(), aMsg->TotalBytes(), aMsg->StreamId(), aMsg->Seekable(), aMsg->Live(), this);
    aMsg->RemoveRef();
    return msg;
}

Msg* Rewinder::ProcessMsg(MsgMetaText* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgHalt* aMsg)
{
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgFlush* aMsg)
{
    //ASSERT(!iBuffering);
    //DrainQueue(*iQueueCurrent);
    //DrainQueue(*iQueueNext);
    return aMsg;
}

Msg* Rewinder::ProcessMsg(MsgQuit* aMsg)
{
    return aMsg;
}

void Rewinder::Rewind()
{
    AutoMutex a(iLock);
    if (iBuffering) {
        // write any msgs from iQueueCurrent into iQueueNext, then set iQueueNext as iQueueCurrent
        while (!iQueueCurrent->IsEmpty()) {
            iQueueNext->Enqueue(iQueueCurrent->Dequeue());
        }
        MsgQueue* tmpQueue = iQueueCurrent;
        iQueueCurrent = iQueueNext;
        iQueueNext = tmpQueue;
    }
    else {
        ASSERTS();
    }
}

void Rewinder::Stop()
{
    AutoMutex a(iLock);
    if (iBuffering) {
        iBuffering = false;
        DrainQueue(*iQueueNext);
    }
    else {
        ASSERTS();
    }
}

EStreamPlay Rewinder::OkToPlay(TUint aTrackId, TUint aStreamId)
{
    return iStreamHandler->OkToPlay(aTrackId, aStreamId);
}

TUint Rewinder::TrySeek(TUint aTrackId, TUint aStreamId, TUint64 aOffset)
{
    AutoMutex a(iLock);
    // can't seek if buffering current track
    ASSERT(!iBuffering || (aTrackId != iTrackId) || (aStreamId != iStreamId));
    return iStreamHandler->TrySeek(aTrackId, aStreamId, aOffset);
}

TUint Rewinder::TryStop(TUint aTrackId, TUint aStreamId)
{
    AutoMutex a(iLock);
    // can't stop if buffering current track
    ASSERT(!iBuffering || (aTrackId != iTrackId) || (aStreamId != iStreamId));
    return iStreamHandler->TryStop(aTrackId, aStreamId);
}
