#include <OpenHome/Media/Codec/Container.h>
#include <OpenHome/OhNetTypes.h>
#include <OpenHome/Buffer.h>
#include <OpenHome/Private/Printer.h>
#include <OpenHome/Private/Debug.h>
#include <OpenHome/Media/Msg.h>
#include <OpenHome/Av/Debug.h>

using namespace OpenHome;
using namespace OpenHome::Media;
using namespace OpenHome::Media::Codec;


// ContainerBase

ContainerBase::ContainerBase()
    : iMsgFactory(NULL)
    , iUpstreamElement(NULL)
    , iStreamHandler(NULL)
    , iAudioEncoded(NULL)
    , iExpectedFlushId(MsgFlush::kIdInvalid)
{
}

ContainerBase::~ContainerBase()
{
    ReleaseAudioEncoded();
}

Msg* ContainerBase::PullMsg()
{
    Msg* msg = iUpstreamElement->Pull();
    msg = msg->Process(*this);
    return msg;
}

void ContainerBase::ReleaseAudioEncoded()
{
    if (iAudioEncoded != NULL) {
        iAudioEncoded->RemoveRef();
        iAudioEncoded = NULL;
    }
}

void ContainerBase::Construct(MsgFactory& aMsgFactory, IPipelineElementUpstream& aUpstreamElement, IStreamHandler& aStreamHandler)
{
    iMsgFactory = &aMsgFactory;
    iUpstreamElement = &aUpstreamElement;
    iStreamHandler = &aStreamHandler;
}

TBool ContainerBase::Recognise(Brx& /*aBuf*/)
{
    return false; // should help detect if there's a problem
}

Msg* ContainerBase::Pull()
{
    //Log::Print("ContainerBase::Pull\n");
    Msg* msg = NULL;
    while (msg == NULL) {
        msg = PullMsg();
    }
    return msg;
}

EStreamPlay ContainerBase::OkToPlay(TUint aTrackId, TUint aStreamId)
{
    return iStreamHandler->OkToPlay(aTrackId, aStreamId);
}

TUint ContainerBase::TrySeek(TUint aTrackId, TUint aStreamId, TUint64 aOffset)
{
    Log::Print("ContainerBase::TrySeek\n");
    // seek to absolute offset in stream by default
    iExpectedFlushId = iStreamHandler->TrySeek(aTrackId, aStreamId, aOffset);
    return iExpectedFlushId;
}

TUint ContainerBase::TryStop(TUint aTrackId, TUint aStreamId)
{
    //if (!iQuit) {
    iExpectedFlushId = iStreamHandler->TryStop(aTrackId, aStreamId);
    //}
    //else {
    //    return MsgFlush::kIdInvalid;
    //}
    return iExpectedFlushId;
}

Msg* ContainerBase::ProcessMsg(MsgAudioEncoded* aMsg)
{
    return aMsg;
}

Msg* ContainerBase::ProcessMsg(MsgAudioPcm* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* ContainerBase::ProcessMsg(MsgSilence* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* ContainerBase::ProcessMsg(MsgPlayable* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* ContainerBase::ProcessMsg(MsgDecodedStream* /*aMsg*/)
{
    ASSERTS(); // expect this Msg to be generated by a downstream decoder element
    return NULL;
}

Msg* ContainerBase::ProcessMsg(MsgTrack* aMsg)
{
    return aMsg;
}

Msg* ContainerBase::ProcessMsg(MsgEncodedStream* aMsg)
{
    // replace iStreamHandler with own
    return aMsg;
}

Msg* ContainerBase::ProcessMsg(MsgMetaText* aMsg)
{
    return aMsg;
}

Msg* ContainerBase::ProcessMsg(MsgHalt* aMsg)
{
    return aMsg;
}

Msg* ContainerBase::ProcessMsg(MsgFlush* aMsg)
{
    ReleaseAudioEncoded();
    return aMsg;
}

Msg* ContainerBase::ProcessMsg(MsgQuit* aMsg)
{
    return aMsg;
}


// ContainerNull

ContainerNull::ContainerNull()
    : ContainerBase()
{
}

TBool ContainerNull::Recognise(Brx& /*aBuf*/)
{
    return true;
}


// ContainerFront

ContainerFront::ContainerFront(Container& aContainer, IMsgProcessor& aMsgProcessor, IPipelineElementUpstream& aUpstreamElement)
    : iContainer(aContainer)
    , iMsgProcessor(aMsgProcessor)
    , iUpstreamElement(aUpstreamElement)
    , iAccumulator(0)
    , iExpectedFlushId(MsgFlush::kIdInvalid)
{
}

Msg* ContainerFront::Pull()
{
    // this is needed to handle a pull coming into the container, and being
    // called on the inner_container, which then calls back into the container
    // i.e., upstream_element <- [container] <- downstream_element
    // where container encapsulates:
    // <- [container <- inner_container <- container] <-
    // but this would require container's Pull() function to have two modes
    // of behaviour, so use this pseudo-element at the front.
    //Log::Print("ContainerFront::Pull: %u\n", ++iAccumulator);
    Msg* msg = NULL;
    if (iContainer.iAudioEncoded && !iContainer.iRecognising)
    {
        msg = iContainer.iAudioEncoded;
        iContainer.iAudioEncoded = NULL;
    }
    while (msg == NULL) {
        msg = iUpstreamElement.Pull();
        msg = msg->Process(iMsgProcessor);
    }
    return msg;
}

EStreamPlay ContainerFront::OkToPlay(TUint aTrackId, TUint aStreamId)
{
    return iContainer.iStreamHandler->OkToPlay(aTrackId, aStreamId);
}

TUint ContainerFront::TrySeek(TUint aTrackId, TUint aStreamId, TUint64 aOffset)
{
    Log::Print("ContainerFront::TrySeek\n");
    // seek to absolute offset in stream by default
    iExpectedFlushId = iContainer.iStreamHandler->TrySeek(aTrackId, aStreamId, aOffset);
    return iExpectedFlushId;
}

TUint ContainerFront::TryStop(TUint aTrackId, TUint aStreamId)
{
    //if (!iQuit) {
    iExpectedFlushId = iContainer.iStreamHandler->TryStop(aTrackId, aStreamId);
    //}
    //else {
    //    return MsgFlush::kIdInvalid;
    //}
    return iExpectedFlushId;
}


// Container

Container::Container(MsgFactory& aMsgFactory, IPipelineElementUpstream& aUpstreamElement)
    : iMsgFactory(aMsgFactory)
    , iActiveContainer(NULL)
    , iStreamHandler(NULL)
    , iRecognising(false)
    , iAudioEncoded(NULL)
    , iExpectedFlushId(0)
{
    iContainerFront = new ContainerFront(*this, *this, aUpstreamElement);
    iContainerNull = new ContainerNull();
    AddContainer(iContainerNull);
    //iContainers.push_back(iContainerNull);
    iActiveContainer = iContainerNull;
}

Container::~Container()
{
    for (size_t i=0; i<iContainers.size(); i++) {
        delete iContainers[i];
    }
    delete iContainerFront;
}

void Container::AddContainer(ContainerBase* aContainer)
{
    aContainer->Construct(iMsgFactory, *iContainerFront, *iContainerFront);

    IContainerBase* container = aContainer;
    if (iContainers.size() >= 1) {
        // if we have >= 1 container, must have NULL container at end;
        // pop NULL container and set up so it's re-attached at end
        container = iContainers.back();
        iContainers.pop_back();
        iContainers.push_back(aContainer);
    }
    iContainers.push_back(container);
}

Msg* Container::Pull()
{
    //Log::Print("Container::Pull\n");
    // can't break the call stack, so after a new MsgEncodedStream comes in and
    // we're put into iRecognising mode, can't just pull through next inner
    // container, otherwise we'd pass on some audio, and any downstream element
    // may start trying to decode it.
    // should pull on iContainerFront here, allowing next inner container to be
    // recognised and slotted in place and only THEN may control be handed over.
    if (iRecognising) {
        return iContainerFront->Pull();
    }
    else {
        ASSERT(iActiveContainer != NULL); // should have at least ContainerNull
        return iActiveContainer->Pull();
    }
}

//Msg* Container::ProcessMsg(MsgAudioEncoded* aMsg)
//{
//    // doing this for the main Container (with ContainerNull) works fine
//    // so the problem is likely to be with the complex ProcessMsg(MsgAudioEncoded) func
//    return aMsg;
//}

Msg* Container::ProcessMsg(MsgAudioEncoded* aMsg)
{
    // read enough audio for recognise buffer
    // then iterate over containers, calling Recognise
    // once recognised (at least the NULL container, which should be last, MUST recognise ALL streams)
    // somehow pass the audio into the container (call Pull on it?)
    // then hand future control over to the container
    Msg* msg = aMsg;
    if (iRecognising && (iAudioEncoded == NULL || iAudioEncoded->Bytes() < kMaxRecogniseBytes)) {
        // still to recognise stream and not enough MsgAudioEncoded data to perform recognition
        if (iAudioEncoded == NULL) {
            iAudioEncoded = aMsg;
        }
        else {
            iAudioEncoded->Add(aMsg);
        }
        msg = NULL;
    }
    if (iRecognising && (iAudioEncoded != NULL) && (iAudioEncoded->Bytes() >= kMaxRecogniseBytes)) {
        // we can only CopyTo a max of kMaxRecogniseBytes bytes.  If we have more data than that,
        // split the msg, select a container then add the fragments back together before processing
        MsgAudioEncoded* remaining = NULL;
        if (iAudioEncoded->Bytes() > kMaxRecogniseBytes) {
            remaining = iAudioEncoded->Split(kMaxRecogniseBytes);
        }
        iAudioEncoded->CopyTo(iReadBuf);
        iAudioEncoded->Add(remaining); // reconstitute audio msg
        Brn recogBuf(iReadBuf, kMaxRecogniseBytes);

        // iterate over containers, calling recognise
        for (size_t i=0; i<iContainers.size(); i++) {
            IContainerBase* container = iContainers[i];
            TBool recognised = container->Recognise(recogBuf);
            if (recognised) {
                Log::Print("recognised\n");
                iActiveContainer = container;
                iRecognising = false;
                msg = iActiveContainer->Pull(); // get audio into iActiveContainer
                break;
            }
        }
        ASSERT(!iRecognising); // all streams should be recognised by ContainerNull if nothing else
    }
    return msg;
}

Msg* Container::ProcessMsg(MsgAudioPcm* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Container::ProcessMsg(MsgSilence* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Container::ProcessMsg(MsgPlayable* /*aMsg*/)
{
    ASSERTS(); // only expect encoded audio at this stage of the pipeline
    return NULL;
}

Msg* Container::ProcessMsg(MsgDecodedStream* /*aMsg*/)
{
    ASSERTS(); // expect this Msg to be generated by a downstream decoder element
    return NULL;
}

Msg* Container::ProcessMsg(MsgTrack* aMsg)
{
    return aMsg;
}

Msg* Container::ProcessMsg(MsgEncodedStream* aMsg)
{
    iRecognising = true;
    iStreamHandler = aMsg->StreamHandler();
    MsgEncodedStream* msg = iMsgFactory.CreateMsgEncodedStream(aMsg->Uri(), aMsg->MetaText(), aMsg->TotalBytes(), aMsg->StreamId(), aMsg->Seekable(), aMsg->Live(), this);
    aMsg->RemoveRef();
    return msg;
}

Msg* Container::ProcessMsg(MsgMetaText* aMsg)
{
    return aMsg;
}

Msg* Container::ProcessMsg(MsgHalt* aMsg)
{
    return aMsg;
}

Msg* Container::ProcessMsg(MsgFlush* aMsg)
{
    if (iAudioEncoded)
    {
        iAudioEncoded->RemoveRef();
        iAudioEncoded = NULL;
    }
    return aMsg;
}

Msg* Container::ProcessMsg(MsgQuit* aMsg)
{
    return aMsg;
}

EStreamPlay Container::OkToPlay(TUint aTrackId, TUint aStreamId)
{
    return iActiveContainer->OkToPlay(aTrackId, aStreamId);
}

TUint Container::TrySeek(TUint aTrackId, TUint aStreamId, TUint64 aOffset)
{
    Log::Print("Container::TrySeek\n");
    // seek to absolute offset in stream by default
    iExpectedFlushId = iActiveContainer->TrySeek(aTrackId, aStreamId, aOffset);
    return iExpectedFlushId;
}

TUint Container::TryStop(TUint aTrackId, TUint aStreamId)
{
    //if (!iQuit) {
    iExpectedFlushId = iActiveContainer->TryStop(aTrackId, aStreamId);
    //}
    //else {
    //    return MsgFlush::kIdInvalid;
    //}
    return iExpectedFlushId;
}
